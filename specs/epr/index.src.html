<h1>Entry Point Regulation</h1>
<pre class="metadata">
Status: ED
Group: WebAppSec
ED: https://w3c.github.io/webappsec/specs/epr/
Shortname: EPR
Level: 1
Editor: David Ross, Google Inc., drx@google.com
Editor: Mike West 56384, Google Inc., mkwst@google.com
Abstract:
  This document allows authors to mitigate the risk of certain kinds of
  cross-site scripting (XSS) and cross-site request forgery (XSRF) attacks
  by defining a mechanism which an author can use to assert restrictions upon
  the ways in which resources may be fetched from an origin.
Indent: 2
</pre>
<pre class="anchors">
spec: CSP2; urlPrefix: https://www.w3.org/TR/CSP2/
  type: dfn
    text: content-security-policy
    text: content-security-policy-report-only
    text: default-src
    text: report-uri
    text: protected resource
    text: security policy
    text: send violation reports
    text: report a violation
    text: violation report; url: example-violation-report
    url: enforce
      text: enforce
      text: enforced
    url: monitor
      text: monitor
      text: monitored
spec: DOM; urlPrefix: http://www.w3.org/TR/dom/
  type: interface
    text: Document; url: interface-document
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: fetching
    text: process response
    text: append; url: concept-header-list-append
    text: response; url: concept-response
    text: request; url: concept-request
    text: header; url: concept-header
    text: url; for: request; url: concept-request-url
    text: mode; for: request; url: concept-request-mode
    text: body; for: request; url: concept-request-body
    text: client; for: request; url: concept-request-client
    text: credentials; for: request; url: concept-request-client
    text: context; for: request; url: concept-request-context
    text: method; for: request; url: concept-request-method
    text: context frame type; for: request; url: concept-request-context-frame-type
    text: header list; for: request; url: concept-request-header-list
    text: url; for: response; url: concept-response-url
    text: header list; for: response; url: concept-response-header-list
    text: network error; url: concept-network-error
spec: HTML5; urlPrefix: http://www.w3.org/TR/html5/
  type: dfn
    urlPrefix: infrastructure.html
      text: ascii case-insensitive match; url: ascii-case-insensitive
    urlPrefix: browsers.html
      text: ancestor browsing context
      text: browsing context
      text: creating a new document object; url: create-a-document-object
      text: nested browsing context
    urlPrefix: webappapis.html
      text: environment settings object; url: settings-object
      text: incumbent settings object
      text: responsible document
      text: responsible browsing context
      text: relevant settings object for a script
spec: HTML; urlPrefix: https://html.spec.whatwg.org/multipage/
  urlPrefix: workers.html
    type: dfn
      text: set up a worker environment settings object
    type: interface
      text: SharedWorker
spec: MIX; urlPrefix: https://w3c.github.io/webappsec/specs/mixedcontent/
  type: dfn
    text: embedding document
    text: strict mode
    text: block-all-mixed-content
    url: a-priori-insecure-url
      text: a priori insecure origin
      text: a priori insecure url
      text: a priori insecure
    url: potentially-secure-origin
      text: potentially secure origin
      text: potentially secure url
      text: potentially secure
spec: SERVICE-WORKERS; urlPrefix: https://slightlyoff.github.io/ServiceWorker/spec/service_worker/
  type: interface
    text: ServiceWorker; url: service-worker-interface
spec: URL; urlPrefix: http://www.w3.org/TR/url/
  type: dfn
    text: URL parser; url: concept-url-parser
    text: base URL; url: concept-base-url
    text: path; for: URL; url: concept-url-path
    text: query; for: URL; url: concept-url-query
    text: fragment; for: URL; url: concept-url-fragment
    text: percent decode
  type: interface
    text: URL; url: concept-url
  type: attribute
    text: host; for: URL; url: concept-url-host
    text: path; for: URL; url: concept-url-path
    text: port; for: URL; url: concept-url-port
    text: scheme; for: URL; url: concept-url-scheme
spec: WEBIDL2; urlPrefix: https://heycam.github.io/webidl/
  type: interface
    text: USVString; url: idl-USVString
    text: boolean; url: idl-boolean
spec: WORKERS; urlPrefix: http://www.w3.org/TR/workers/
  type: interface
    text: Worker
spec: RFC5234; urlPrefix: https://tools.ietf.org/html/rfc5234
  type: dfn
    text: BIT; url: appendix-B.1
    text: WSP; url: appendix-B.1
spec: RFC6454; urlPrefix: https://tools.ietf.org/html/rfc6454
  type: dfn
    text: origin; url: section-3.2
spec: RFC6455; urlPrefix: https://tools.ietf.org/html/rfc6455
  type: dfn
    text: establish a websocket connection; url: section-4.1
    text: fail the websocket connection; url: section-7.1.7
spec: RFC6797; urlPrefix: https://tools.ietf.org/html/rfc6797
  type: dfn
    text: Strict-Transport-Security; url: section-6.1
    text: congruent match; url: section-8.2
    text: superdomain match; url: section-8.2
    text: includeSubDomains; url: section-6.1.2
    text: Known HSTS Host Domain Name Matching; url: section-8.2
    text: Known HSTS Host; url: section-8.1.1
spec: RFC7231; urlPrefix: https://tools.ietf.org/html/rfc7231
  type: dfn
    text: Vary; url: section-7.1.4
    text: resource representation; url: section-3
spec: RFC7234; urlPrefix: https://tools.ietf.org/html/rfc7234
  type: dfn
    text: Cache-Control; url: section-5.2
    text: no-store; url: section-5.2.2.3
spec: RFC7240; urlPrefix: https://tools.ietf.org/html/rfc7240
  type: dfn
    text: Prefer; url: section-2
</pre>

<!-- BIBLIOGRAPHY -->
<pre class="biblio">
{
  "ISOLATION": {
    "authors": [ "Eric Y. Chen", "Jason Bau", "Charles Reis", "Adam Barth", "Collin Jackson" ],
    "title": "App Isolation: Get the Security of Multiple Browsers with Just One",
    "href": "http://www.collinjackson.com/research/papers/appisolation.pdf",
    "publisher": "ACM"
  },
  "URL": {
    "authors": [ "Anne van Kesteren", "Sam Ruby" ],
    "title": "URL",
    "href": "http://www.w3.org/TR/url",
    "status": "WD",
    "publisher": "W3C"
  },
  "WEBIDL2": {
    "authors": [ "Cameron McCormack", "Boris Zbarsky" ],
    "title": "Web IDL (Second Edition)",
    "href": "https://heycam.github.io/webidl/",
    "status": "ED",
    "publisher": "W3C"
  },
  "MANIFEST": {
    "authors": [ "Marcos Caceres", "Kenneth Rohde Christiansen", "Mounir Lamouri", "Anssi Kostiainen" ],
    "href": "https://w3c.github.io/manifest/",
    "title": "Manifest for a web application",
    "publisher": "W3C",
    "status": "WD"
  }
}
</pre>

<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  EPR provides a browser-enforced mechanism for validating an entry point
  policy supplied with a web application.  External references and navigations
  to non-entry points can then be restricted based on this policy.

  Entry point regulation may be considered an implementation of concepts
  introduced by Charlie Reis et al. in [[ISOLATION]].

  <h3 id="goals">Goals</h3>

  TBD.

  <h3 id="examples">Examples</h3>

  TBD.
</section>

<!--
████████  ████████ ████████ ████ ██    ██ ████ ████████ ████  ███████  ██    ██  ██████
██     ██ ██       ██        ██  ███   ██  ██     ██     ██  ██     ██ ███   ██ ██    ██
██     ██ ██       ██        ██  ████  ██  ██     ██     ██  ██     ██ ████  ██ ██
██     ██ ██████   ██████    ██  ██ ██ ██  ██     ██     ██  ██     ██ ██ ██ ██  ██████
██     ██ ██       ██        ██  ██  ████  ██     ██     ██  ██     ██ ██  ████       ██
██     ██ ██       ██        ██  ██   ███  ██     ██     ██  ██     ██ ██   ███ ██    ██
████████  ████████ ██       ████ ██    ██ ████    ██    ████  ███████  ██    ██  ██████
-->
<section>
  <h2 id="key-concepts">Key Concepts and Terminology</h2>

  The Augmented Backus-Naur Form (ABNF) notation is specified in [[!RFC5234]].
</section>

<!-- Big Text: Delivery -->
<section>
  <h2 id="framework">Framework</h2>

  In a nutshell:

  <ol>
    <li>
      UA requests a resource from <code>example.com</code> for the very
      first time.
    </li>
    <li>
      <code>example.com</code> responds with a document that has an
      <code><a>EPR</a></code> header, which tells the UA that it should
      regulate some entry points.

      Somewhere in Fetch after we have the headers, we'll call out to
      [[#process-epr-header]] to take whatever actions we need to take
      here. This means we'll grab an <a>EPR manifest</a> file, and
      store it persistently for use in regulating future requests.
      As the manifest won't yet be available until it is downloaded
      asynchronously, a default policy ([[#no-data-policy]]) will
      apply.  The default policy will also apply if the downloaded
      manifest fails to parse.
    </li>
    <li>
      Subsequent navigations and resource requests from <code>example.com</code>
      will run through [[#process-request]] to determine whether they <a>match</a>
      the ruleset defined in the <a>EPR manifest</a> we processed above.

      If they don't match a ruleset, a default action will apply. If no default
      is specified in the manifest, a hardcoded default policy will apply. A
      different default policy may be specified for navigations vs. resource
      loads.

      Hardcoded default policy for both navigations (defaultNavBehavior) and
      requests (defaultResBehavior) specifies that GET requests are allowed, with
      path information but no querystring or hash data. Requests using all other
      verbs are dropped.  The intent of this default policy is to prevent
      reflected and DOM-based XSS.  Other available default policy options that
      may be specified for defaultNavBehavior or defaultResBehavior:

      <ul>
        <li>Block all requests</li>
        <li>Navigate to a specified URL</li>
        <li>defaultResBehavior only: Allow the request but drop cookies
        (This is only a safe option for resource request policy because even
        non-authenticated XSS is problematic)
        </li>
      </ul>
      ISSUE: A lot of the above is now redundant with the defaultAction section below.
    </li>
    <li>
      That's it!
    </li>
  </ol>

  <h3 id="epr-header">The <code>EPR</code> HTTP Response Header Field</h3>

  Servers may request the protections outlined in this document by sending an
  <dfn local-lt="EPR"><code>EPR</code> HTTP response header field</dfn> along
  with a response. This request is represented by the following ABNF:

  <pre>
    "EPR:" *<a>WSP</a> "1" *<a>WSP</a>
  </pre>

  User agent conformance details upon receipt of such a header are explained in
  [[#process-epr-header]].

  <h3 id="manifest">Entry Point Manifests</h3>

  An <dfn>EPR manifest</dfn> is a JSON file containing entry point regulation
  policy data for an <a>origin</a>.

  Servers which opt-in to EPR protections via the <code><a>EPR</a></code> header
  MUST make a manifest file available via [[MANIFEST]].  EPR rules are included
  in a manifest via the <code>epr_manifest</code> attribute.

  <div class="example">
    <pre>
      {
        "site": ...
        ...,
        "<a dict-member>epr</a>": {
          "<a dict-member>reportURL</a>": "https://example.com/reporting-endpoint",
          "<a dict-member>navigationBehavior</a>": "allowStrippedGET",
          "<a dict-member>subresourceBehavior</a>": "allowStrippedGET",
          "<a dict-member>rules</a>": [
            {
              "<a dict-member>path</a>": "/",
              "<a dict-member>frameTypes</a>": [ "top-level", "auxiliary", "nested" ],
              "<a dict-member>allowData</a>": false
            },
            {
              "<a dict-member>regex</a>": "^/\\d+$",
              "<a dict-member>frameTypes</a>": [ "top-level", "auxiliary", "nested" ],
              "<a dict-member>allowData</a>": false
            },
            ...
            {
              "<a dict-member>path</a>": "/image",
              "<a dict-member>contexts</a>": [ "image", "imageset" ],
              "<a dict-member>allowData</a>": true
            },
          ]
        }
      }
    </pre>
  </div>

  <h4 id="manifest-epr">The <code>epr</code> manifest member</h4>

  The policy data that makes up the <a>EPR manifest</a> is delivered via an
  <dfn dict-member for="EPR Manifest"><code>epr</code></dfn> member of an
  application manifest [[!MANIFEST]]. This member's value is an dictionary
  adhering to the following IDL:

  <pre class="idl">
    enum EPRBehavior {
      "allow",
      "block",
      "redirect",
      "allowUnauthenticated",
      "allowStrippedGET"
    };

    dictionary EPRPolicy {
      USVString? reportURL;
      EPRBehavior navigationBehavior = "allowStrippedGET";
      EPRBehavior subresourceBehavior = "allowStrippedGET";
      sequence&lt;EPRRule&gt; rules;
    };
  </pre>
  <dl dfn-for="EPRPolicy">
    <dt><dfn dict-member>reportURL</dfn></dt>
    <dd>
      A URL to which violation reports will be sent. See TODO for user agent
      conformance requirements. Use the allow behavior to simulate a 
      "report only" mode that does not actually block requests but does send 
      reports back to the report URL.
      
      ISSUE: Which TODO (mentioned above)?
    </dd>
    <dt><dfn dict-member>navigationBehavior</dfn></dt>
    <dd>
      If a navigational request doesn't <a>match</a> {{EPRPolicy/rules}}, this
      property defines the action the user agent will take. Detailed conformance
      requirements can be found in [[#process-request]], and a high-level
      description of the behaviors can be found in [[#manifest-behaviors]].
    </dd>
    <dt><dfn dict-member>subresourceBehavior</dfn></dt>
    <dd>
      If a non-navigational request doesn't <a>match</a> {{EPRPolicy/rules}}, this
      property defines the action the user agent will take. Detailed conformance
      requirements can be found in [[#process-request]], and a high-level
      description of the behaviors can be found in [[#manifest-behaviors]].
    </dd>
    <dt><dfn dict-member>rules</dfn></dt>
    <dd>
      The ruleset which should be applied. Details are in [[#manifest-ruleset]].
    </dd>
  </dl>

  <h4 id="manifest-ruleset">Ruleset</h4>

  EPR manifests define a set of <dfn>rules</dfn> for a site, governing a user
  agent's <a>fetching</a> behavior for <a>requests</a> made to that site's
  <a>origin</a>. Each rule is scoped to a specific subset of an origin's
  URLs via a path prefix or a regular expression, and contains a set of
  behaviors which MUST be applied to <a>requests</a> which match the rule's
  scope (as defined in [[#matching]]).

  DR: This implies there is something akin to defaultResBehavior and
  defaultNavBehavior that defines the behavior on a per-rule basis.  Today
  the prototype does not allow for this.  I would prefer not to make this
  configurable on a per-rule basis for simplicity's sake.  But if there's
  a use case we could add it.

  The following IDL defines rules' syntax:

  <pre class="idl">
    enum RequestContext {
        "audio", "beacon", "cspreport", "download", "embed", "eventsource",
        "favicon", "fetch", "font", "form", "frame", "hyperlink", "iframe",
        "image", "imageset", "import", "internal", "location", "manifest",
        "metarefresh", "object", "ping", "plugin", "prefetch", "script",
        "serviceworker", "sharedworker", "subresource", "style", "track",
        "video", "worker", "xmlhttprequest", "xslt"
    };

    enum RequestFrameType {
      "auxiliary", "nested", "none", "top-level"
    };

    dictionary EPRRule {
      USVString? path;
      USVString? regex;
      sequence&lt;RequestContext&gt; contexts;
      sequence&lt;RequestFrameType&gt; frameTypes;
      boolean allowData;
    };
  </pre>
  <dl dfn-for="EPRRule">
    <dt><dfn dict-member>path</dfn></dt>
    <dd>
      A path prefix defining a <a>rule</a>'s scope. See [[#matching]] for user
      agent conformance requirements.
    </dd>
    <dt><dfn dict-member>regex</dfn></dt>
    <dd>
      A regular expression, defining a <a>rule</a>'s scope. See [[#matching]]
      for user agent conformance requirements.
    </dd>
    <dt><dfn dict-member>contexts</dfn></dt>
    <dd>
      A set of <a for="request">contexts</a> to which this rule applies. See
      [[#matching]] for user agent conformance requirements.
    </dd>
    <dt><dfn dict-member>frameTypes</dfn></dt>
    <dd>
      A set of <a for="request">context frame types</a> to which this rule
      applies. See [[#matching]] for user agent conformance requirements.
    </dd>
    DR: This adds a little bit of complexity.  I would happy to leave it
    out as I don't necessarily see a use case for specifying the frame type.
    <dt><dfn dict-member>allowData</dfn></dt>
    <dd>
      If <code>true</code>, then matching <a>requests</a>'
      <a for="request">URL</a>s are allowed to contain non-empty
      <a for="URL">query</a> and <a for="URL">fragment</a> properties,
      and <a>requests</a>' <a for="request">body</a> may be non-null.

      See [[#process-request]] for user agent conformance requirements.
    </dd>
  </dl>

  <h4 id="manifest-behaviors">Behaviors</h4>

  If a <a>request</a> does not <a>match</a> the ruleset defined in an <a>EPR
  manifest</a>'s {{EPRPolicy/rules}} property, then the user agent looks to
  either {{EPRPolicy/navigationBehavior}} or {{EPRPolicy/subresourceBehavior}}
  to determine what action to take.

  The following behaviors are defined (and, if none is explicitly specified,
  then <a>allowStrippedGET</a> is used as a default):

  <dl>
    <dt><dfn>block</dfn></dt>
    <dd>
      Cancel the request entirely, returning a <a>network error</a>.
    </dd>
    <dt><dfn>redirect</dfn></dt>
    <dd>
      Redirect the request to a specified URL.

      ISSUE: How is this specified?
    </dd>
    <dt><dfn>allowUnauthenticated</dfn></dt>
    <dd>
      Drop cookies and other authentication properties of the request by
      setting it's <a for="request">credentials</a> flag to
      "<code>omit</code>".
    </dd>
    <dt><dfn>allowStrippedGET</dfn></dt>
    <dd>
      Allow <code>GET</code> requests, after setting its
      <a for="request">url</a>'s <a for="URL">fragment</a> and
      <a for="URL">query</a> properties to <code>null</code>.

      <code>POST</code> and other request types will be canceled, returning a
      <a>network error</a>.
    </dd>
  </dl>

  User agent conformance requirements are defined in [[#process-request]].
</section>

<!-- Big Text: Algorithms -->
<section>
  <h2 id="algorithms">Processing Algorithms</h2>

  <h3 id="process-request">
    Process <var>request</var>
  </h3>

  <ol>
    <li>
      Let <var>rules</var> be the <a>rules</a> which a user agent has stored
      for <var>request</var>'s <a for="request">URL</a>'s <a>origin</a>.
    </li>
    <li>
      If <var>rules</var> is the empty set, abort these steps.
    </li>
    ISSUE: In theory there can be a manifest with no rules.  In that case EPR
    is enforced for the origin (defaultResBehavior and defaultNavBehavior)
    even when there are no rules.  So I think we need to describe some higher
    level container than just "rules".
    <li>
      Let <var>matched</var> be <code>false</code>.
    </li>
    <li>
      For each <var>rule</var> in <var>rules</var>, if <var>request</var>
      <a>matches</a> <var>rule</var>:

      <ol>
        <li>
          Set <var>matched</var> to <code>true</code>.
        </li>
        <li>
          If <var>rule</var>'s {{EPRRule/allowData}} is <code>false</code>, then
          perform the [[#manifest-behaviors]] if any of the following statements
          are true:

          <ol>
            <li>
              <var>request</var>'s <a for="request">URL</a>'s
              <a for="URL">fragment</a> property is not <code>null</code>.
            </li>
            <li>
              <var>request</var>'s <a for="request">URL</a>'s
              <a for="URL">query</a> property is not <code>null</code>.
            </li>
            <li>
              <var>request</var>'s <a for="request">body</a> property is not
              <code>null</code>.
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li>
      If <var>matched</var> is <var>false</var>, perform the [[#manifest-behaviors]].
    </li>
  </ol>

  <h3 id="no-data-policy">
    NO DATA
  </h3>
  
  TODO: Fill in with detail from https://lists.w3.org/Archives/Public/public-webappsec/2014Nov/0018.html

  <h3 id="process-epr-header">
    Process <var>response</var>'s <code>EPR</code> header
  </h3>

  Given a <a>response</a> (<var>response</var>), this algorithm parses its
  <a for="response">header list</a> to extract an <code><a>EPR</a></code>
  header field. If such a field is present, the user agent MUST fetch and
  process an <a>EPR manifest</a> from <var>response</var>'s <a>origin</a>
  unless:
  <ul>
  <li>The request was for a manifest file.  (So as not to go into an
  infinite loop.)</li>
  <li>A manifest for this origin is already cached at the user agent.</li>
  <li>There is already a pending manifest request for the origin.</li>
  </ul>

  To <a>process response</a> <var>response</var>, execute the following steps:

  <ol>
    <li>
      ISSUE: Do we process a header for any response? Only responses to
      top-level requests?
      DR: Any response (except for under the conditions mentioned above).
      We want EPR to "start happening" even if it's a resource request from
      a third party site.
    </li>
    <li>
      If <var>response</var>'s <a for="response">URL</a> is <a><i lang="la">a
      priori</i> insecure</a>, abort these steps.
    </li>
    <li>
      If <var>response</var>'s <a for="response">header list</a> contains a
      <a>header</a> named <code><a>EPR</a></code>, then:

      <ol>
        <li>
          Let <var>manifest URL</var> be the manifest URL provided by 
          [[MANIFEST]].
        </li>
        <li>
          Let <var>request</var> be a <a>request</a> whose
          <a for="request">method</a> is <code>GET</code>,
          <a for="request">URL</a> is <var>manifest URL</var>,
          <a for="request">context frame type</a> is <code>none</code>,
          <a for="request">context</a> is <code>manifest</code>, and
          <a for="request">credentials</a> is <code>omit</code>.
        </li>
        <li>
          <a>Fetch</a> <var>request</var>.
        </li>
        <li>
          To <a>process response</a> for the <a>response</a> <var>manifest
          response</var>:

          <ol>
            <li>
              TODO.  Need to discuss storage & caching.  Also it should be 
              possible for the user to manually clear stored manifests
              when they clear their browser history.
              the
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <h3 id="matching">
    Does <var>request</var> match <var>rule</var>?
  </h3>

  A <a>request</a> (<var>request</var>) is said to <dfn>match</dfn> a
  <a>rule</a> (<var>rule</var>) if the following algorithm returns
  <code>Matches</code>:

  <ol>
    <li>
      If <var>request</var>'s <a for="request">context</a> is not in
      <var>rule</var>'s {{EPRRule/contexts}} list, return <code>Does Not
      Match</code>.
    </li>
    <li>
      If <var>request</var>'s <a for="request">context frame type</a> is not in
      <var>rule</var>'s {{EPRRule/frameTypes}} list, return <code>Does Not
      Match</code>.
    </li>
    ISSUE: Remove frame type?
    <li>
      If <var>rule</var> has a {{EPRRule/path}} property whose value is
      neither <code>null</code> nor <code>undefined</code>:

      <ol>
        <li>
          Let <var>rule path</var> be <var>rule</var>'s {{EPRRule/path}}.
        </li>
        <li>
          Let <var>exact match</var> be <code>false</code> if the final
          character of <var>rule path</var> is the U+002F SOLIDUS character
          (<code>/</code>), and <code>true</code> otherwise.
        </li>
        <li>
          Let <var>rule path list</var> be the result of splitting <var>rule
          path</var> on the U+002F SOLIDUS character (<code>/</code>).
        </li>
        <li>
          If <var>rule path list</var>'s length is greater than <var>url
          path list</var>'s length, return <code>Does Not Match</code>.
        </li>
        <li>
          For each <var>entry</var> in <var>rule path list</var>:

          <ol>
            <li>
              <a>Percent decode</a> <var>entry</var>.
            </li>
            <li>
              <a>Percent decode</a> the first item in <var>url path list</var>.
            </li>
            <li>
              If <var>entry</var> is not an <a>ASCII case-insensitive
              match</a> for the first item in <var>url path list</var>, return
              <code>Does Not Match</code>
            </li>
            <li>
              Pop the first item in <var>url path list</var> off the list.
            </li>
          </ol>
        </li>
        <li>
          If <var>exact match</var> is <code>true</code>, and <var>url path
          list</var> is not empty, return <code>Does Not Match</code>
        </li>
      </ol>
    </li>
    <li>
      If <var>rule</var> has a {{EPRRule/regex}} property whose value is
      neither <code>null</code> nor <code>undefined</code>:

      <ol>
        <li>
          Let <var>rule regex</var> be <var>rule</var>'s {{EPRRule/regex}}.
        </li>
        <li>
          Let <var>url path</var> be the empty string, and for each
          <var>component</var> in <var>request</var>'s
          <a for="request">URL</a>'s <a for="URL">path</a>:

          <ol>
            <li>
              Append the U+002F SOLIDUS character (<code>/</code>) to
              <var>url path</var>.
            </li>
            <li>
              Append <var>component</var> to <var>url path</var>.
            </li>
          </ol>
        </li>
        <li>
          If <var>url path</var> does not <em>regex match</em> (TODO) <var>rule
          regex</var>, return <code>Does Not Match</code>.

          ISSUE: Need to have spec language for this. There's surely a regex
          spec somewhere, right?
          DR: Can we just reference the ECMAScript spec?
        </li>
      </ol>
    </li>
    <li>
      Return <code>Matches</code>.
    </li>
  </ol>
</section>

<!-- Big text: IANA -->
<section>
  <h2 id="iana-considerations">IANA Considerations</h2>

  <h3 id="iana-https">
    The <code>EPR</code> HTTP Request Header Field
  </h3>
  The permanent message header field registry should be updated with the
  following registration [[!RFC3864]]:

  <dl>
    <dt>Header field name</dt>
    <dd>EPR</dd>

    <dt>Applicable protocol</dt>
    <dd>http</dd>

    <dt>Status</dt>
    <dd>standard</dd>

    <dt>Author/Change controller</dt>
    <dd>W3C</dd>

    <dt>Specification document</dt>
    <dd>This specification (See [[#epr-header]])</dd>
  </dl>

<!-- Big text: Thanks -->
<section>
  <h2 id="acknowledgements">Acknowledgements</h2>

  Awesome people are awesome.
</section>
